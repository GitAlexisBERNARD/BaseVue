import { defineComponent as L, toRef as w, computed as m, ref as y, shallowRef as N, onMounted as $, watch as C, openBlock as U, createBlock as O, resolveDynamicComponent as P, normalizeStyle as k, withCtx as q, renderSlot as z, normalizeProps as B, guardReactiveProps as M } from "vue";
const T = "--vc-auto-duration", V = `height var(${T}) cubic-bezier(0.33, 1, 0.68, 1)`, d = { padding: 0 }, Y = 300, K = {
  position: "absolute",
  width: "1px",
  height: "1px",
  padding: "0",
  margin: "-1px",
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  border: "0"
};
function D(t) {
  return t.value ? parseFloat(getComputedStyle(t.value).height) : 0;
}
function R(t) {
  var n;
  return {
    height: `${((n = t.value) == null ? void 0 : n.scrollHeight) || 0}px`
  };
}
function b(t) {
  if (!t.value)
    return {};
  const { transition: n } = getComputedStyle(t.value);
  return n === "all 0s ease 0s" ? { transition: V } : { transition: n };
}
function H(t) {
  if (!t.value)
    return !0;
  const { transition: n } = getComputedStyle(t.value);
  return typeof window.requestAnimationFrame > "u" || matchMedia("(prefers-reduced-motion: reduce)").matches || n.includes("none") || n.includes("height 0s");
}
function j(t = 0) {
  if (t === 0)
    return 0;
  const n = t / 36, l = Math.round((4 + 15 * n ** 0.25 + n / 5) * 10);
  return Number.isFinite(l) ? l : 0;
}
const J = /* @__PURE__ */ L({
  inheritAttrs: !0,
  __name: "Collapse",
  props: {
    when: { type: Boolean },
    baseHeight: { default: 0 },
    as: { default: "div" }
  },
  emits: ["collapse", "expand", "collapsed", "expanded"],
  setup(t, { emit: n }) {
    const l = t, r = n, i = w(l, "when"), o = w(l, "baseHeight"), p = m(() => ({ overflow: "hidden", height: `${o.value}px` })), f = m(() => ({
      ...d,
      ...o.value === 0 ? { display: "none" } : p.value
    })), a = y(null), v = y(i.value ? "expanded" : "collapsed"), c = (e) => v.value = e;
    function F() {
      return i.value ? d : o.value === 0 ? K : f.value;
    }
    const h = N(F()), u = (e) => h.value = e, s = (e) => u({ ...h.value, ...e }), x = y(Y), E = (e) => x.value = e, S = m(() => ({ [T]: `${x.value}ms` }));
    function A() {
      u(d), c("expanded"), r("expanded");
    }
    function _() {
      u(f.value), c("collapsed"), r("collapsed");
    }
    $(() => {
      if (!a.value)
        return;
      const e = j(a.value.scrollHeight - o.value);
      e > 0 && E(e), !i.value && o.value === 0 && u(f.value);
    }), C(i, (e) => {
      if (e) {
        if (H(a))
          return A();
        c("expanding"), r("expand"), u({
          ...d,
          ...p.value,
          ...S.value
        }), requestAnimationFrame(() => {
          s({
            ...R(a),
            ...b(a),
            willChange: "height"
          });
        });
      } else {
        if (H(a))
          return _();
        c("collapsing"), r("collapse"), s({
          ...S.value,
          ...R(a)
        }), requestAnimationFrame(() => {
          s({
            ...p.value,
            ...b(a),
            willChange: "height"
          });
        });
      }
    }), C(o, (e) => {
      i.value || (e > 0 ? s({ display: void 0, height: `${e}px` }) : s({ display: "none" }));
    });
    function I(e) {
      var g;
      e.target === a.value && e.propertyName === "height" && (i.value ? ((g = a.value) == null ? void 0 : g.scrollHeight) === D(a) && A() : o.value === D(a) && _());
    }
    return (e, g) => (U(), O(P(l.as), {
      ref_key: "collapseRef",
      ref: a,
      style: k(h.value),
      onTransitionend: I,
      "data-collapse": v.value
    }, {
      default: q(() => [
        z(e.$slots, "default", B(M({ state: v.value })))
      ]),
      _: 3
    }, 40, ["style", "data-collapse"]));
  }
});
export {
  J as Collapse
};
